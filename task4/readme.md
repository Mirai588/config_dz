# Ассемблер и Интерпретатор Учебной Виртуальной Машины (УВМ)

## Описание Проекта

Данный проект реализует **Ассемблер** и **Интерпретатор** для учебной виртуальной машины (УВМ). Ассемблер преобразует текстовые исходные программы, написанные на ассемблерном языке УВМ, в бинарный формат. Интерпретатор выполняет бинарные файлы, симулируя работу УВМ и сохраняя результаты выполнения.

## Содержание

- [Особенности](#особенности)
- [Требования](#требования)
- [Установка](#установка)
- [Использование](#использование)
  - [Ассемблер](#ассемблер)
  - [Интерпретатор](#интерпретатор)
- [Тестирование](#тестирование)
- [Пример Тестовой Программы](#пример-тестовой-программы)
- [Структура Проекта](#структура-проекта)
- [Лицензия](#лицензия)
- [Контакты](#контакты)

## Особенности

- **Ассемблер**:
  - Читает текстовый файл с ассемблерным кодом УВМ.
  - Преобразует инструкции в бинарный формат согласно спецификации.
  - Генерирует лог-файл в формате JSON с деталями ассемблированных инструкций.

- **Интерпретатор**:
  - Выполняет бинарные файлы, созданные ассемблером.
  - Симулирует память УВМ и выполняет команды.
  - Сохраняет результаты выполнения в JSON-файл, включая диапазон памяти.

- **Тесты**:
  - Проверяют соответствие бинарных байтов ассемблированных команд с ожидаемыми значениями.
  - Обеспечивают надежность и корректность реализации команд УВМ.

## Требования

- **Язык программирования**: Python 3.8+
- **Библиотеки**: Стандартные библиотеки Python (`sys`, `json`, `unittest`, `subprocess`, `os`)
- **Операционная система**: Кроссплатформенная (Windows, macOS, Linux)

## Установка

1. **Клонируйте репозиторий**:
   ```bash
   git clone https://github.com/vicusik-dorogusha/assembler-interpreter.git
   cd assembler-interpreter
   ```

2. **Убедитесь, что у вас установлен Python 3.8 или выше**:
   ```bash
   python --version
   ```

   Если Python не установлен, скачайте и установите его с [официального сайта](https://www.python.org/downloads/).

3. **(Опционально) Создайте и активируйте виртуальное окружение**:
   ```bash
   python -m venv venv
   source venv/bin/activate  # Для Linux/Mac
   venv\Scripts\activate     # Для Windows
   ```

4. **Установите необходимые зависимости**:
   
   В данном проекте используются только стандартные библиотеки Python, дополнительных установок не требуется.

## Использование

### Ассемблер

**Синтаксис**:
```bash
python assembler.py <input_file.asm> <output_file.bin> <log_file.json>
```

**Параметры**:
- `<input_file.asm>`: Путь к текстовому файлу с исходной программой на ассемблере УВМ.
- `<output_file.bin>`: Путь к создаваемому бинарному файлу.
- `<log_file.json>`: Путь к создаваемому лог-файлу в формате JSON.

**Пример**:
```bash
python assembler.py program.asm program.bin program_log.json
```

### Интерпретатор

**Синтаксис**:
```bash
python interpreter.py <binary_file.bin> <memory_dump.json> <memory_start> <memory_end>
```

**Параметры**:
- `<binary_file.bin>`: Путь к бинарному файлу, созданному ассемблером.
- `<memory_dump.json>`: Путь к создаваемому файлу с дампом памяти в формате JSON.
- `<memory_start>`: Начальный адрес диапазона памяти для сохранения результатов.
- `<memory_end>`: Конечный адрес диапазона памяти для сохранения результатов.

**Пример**:
```bash
python interpreter.py program.bin memory_dump.json 0 600
```

## Тестирование

### Запуск Тестов

Тесты написаны с использованием модуля `unittest` и проверяют соответствие бинарных байтов ассемблированных команд с ожидаемыми значениями.

**Команда для запуска тестов**:
```bash
python test_instructions.py
```

**Ожидаемый результат**:
```
....
----------------------------------------------------------------------
Ran 4 tests in 0.1s

OK
```

Если тесты пройдут успешно, вы увидите сообщение `OK`. В случае ошибок будут выведены детали неудачных тестов.

### Структура Тестов

- **test_instructions.py**: Содержит тестовые случаи для проверки каждой команды УВМ. Тесты создают временные ассемблерные файлы, запускают ассемблер, и сравнивают сгенерированный бинарный файл с ожидаемыми байтами.

**Пример тестового случая**:
```python
def test_load_const(self):
    # Тест из условия:
    # A=11,B=149,C=511
    # Ожидаемый результат:
    # 0x5B, 0x09, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00
    expected_bytes = bytes([0x5B, 0x09, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00])
    asm_code = "LOAD_CONST 149, 511\n"
    actual = self.run_assembler(asm_code)
    self.assertEqual(actual, expected_bytes)
```

## Пример Тестовой Программы

Проект включает пример тестовой программы, которая выполняет побитовый циклический сдвиг вправо над двумя векторами длины 8 и записывает результат в новый вектор.

**Файл: `test_program.asm`**
```asm

LOAD_CONST 52, 1000
STORE_TO_MEM 1000, 0, 1000

LOAD_CONST 53, 1001
STORE_TO_MEM 1001, 0, 1001

LOAD_CONST 54, 1002
STORE_TO_MEM 1002, 0, 1002

LOAD_CONST 55, 1003
STORE_TO_MEM 1003, 0, 1003

LOAD_CONST 56, 1004
STORE_TO_MEM 1004, 0, 1004

LOAD_CONST 57, 1005
STORE_TO_MEM 1005, 0, 1005

LOAD_CONST 58, 1006
STORE_TO_MEM 1006, 0, 1006

LOAD_CONST 59, 1007
STORE_TO_MEM 1007, 0, 1007


LOAD_CONST 3, 2000
STORE_TO_MEM 2000, 0, 2000

LOAD_CONST 1, 2001
STORE_TO_MEM 2001, 0, 2001

LOAD_CONST 4, 2002
STORE_TO_MEM 2002, 0, 2002

LOAD_CONST 2, 2003
STORE_TO_MEM 2003, 0, 2003

LOAD_CONST 1, 2004
STORE_TO_MEM 2004, 0, 2004

LOAD_CONST 3, 2005
STORE_TO_MEM 2005, 0, 2005

LOAD_CONST 2, 2006
STORE_TO_MEM 2006, 0, 2006

LOAD_CONST 1, 2007
STORE_TO_MEM 2007, 0, 2007



LOAD_CONST 3000, 3000
STORE_TO_MEM 3000, 0, 3000

LOAD_CONST 3001, 3001
STORE_TO_MEM 3001, 0, 3001

LOAD_CONST 3002, 3002
STORE_TO_MEM 3002, 0, 3002

LOAD_CONST 3003, 3003
STORE_TO_MEM 3003, 0, 3003

LOAD_CONST 3004, 3004
STORE_TO_MEM 3004, 0, 3004

LOAD_CONST 3005, 3005
STORE_TO_MEM 3005, 0, 3005

LOAD_CONST 3006, 3006
STORE_TO_MEM 3006, 0, 3006

LOAD_CONST 3007, 3007
STORE_TO_MEM 3007, 0, 3007




ROTR 2000, 1000, 3000  
ROTR 2001, 1001, 3001  
ROTR 2002, 1002, 3002  
ROTR 2003, 1003, 3003  
ROTR 2004, 1004, 3004  
ROTR 2005, 1005, 3005  
ROTR 2006, 1006, 3006  
ROTR 2007, 1007, 3007  
```

**Описание**:
1. Инициализируются векторы значениями.
2. Выполняется операция `SGN_OP` для каждого элемента, определяющая знак числа и записывающая результат в соответствующие адреса памяти.

**Запуск Ассемблера и Интерпретатора**:
```bash
python assembler.py test_program.asm test_program.bin test_program_log.json
python interpreter.py test_program.bin memory_dump.json 1000 1007
```

**Ожидаемый результат (`result.json`)**:
```json
{
  "1000": 52,
  "1001": 53,
  "1002": 54,
  "1003": 55,
  "1004": 56,
  "1005": 57,
  "1006": 58,
  "1007": 59
}
```



## Структура Проекта

```
assembler-interpreter/
│
├── assembler.py          # Скрипт ассемблера
├── interpreter.py        # Скрипт интерпретатора
├── tests.py              # Тестовый скрипт
├── program.asm           # Пример ассемблерной программы
├── *.json                # Всякая всячина .json
└── README.md             # Этот файл
```